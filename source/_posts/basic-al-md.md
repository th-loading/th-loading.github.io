---
title: 基本算法思路
date: 2022-01-30 16:01:59
tags: algorithm
---

# algorithm  

## 基本思路

1. 容易误判的性质  
    1. 存在多个元素的匹配问题  
    ? 字典树不行，只能匹配一个元素 - 默认了字典树只能有一个元素...  
    ? 哈希方法只能双层嵌套，因为前后缀无法一起匹配 - 通配符...  
    2. 存在逻辑依赖关系的匹配问题  
    ? 由于每个前状态都可能包含多跳的情况，且每个前状态都有特定的状态 (长度为k的DP), 所以难以DP，通过贪心证明 - 基于贪心的DP...  
    ? 由于存在一个不符合拓扑序的更新路径，因此不可使用DP - 定义距离x为DP的含义，而非从头开始，并且可通过的优先队列搜索解决  
    ？每个区间都会受到两侧的区间的影响，难以贪心，分块后可能会有多种情况，难以拆分，不能DP - 考虑递推的转移即可综合考虑两侧，离散化较分块更方便转移，只需要判断能否保留该节点即可，将数值问题转化成能否保留的问题  
    ? 存在不符合条件的部分，影响单调栈/优先队列的特性 - 冗余结构...  
    3. 构造最优策略类问题  
    ? 若存在这样一种策略，一定能够找到一种转移 - 只是一组必要条件，不能证明这种转移是否满足条件（充分性）  
    ? 不断枚举，构造一步、两步的贪心，简化了部分的转移条件，无法构造出一种解法 - 尝试从逆向/整体结构入手，或直接构造后证明  


2. 容易忽略的观察  
    1. 常数  
    有限数量的集合, 能够简化到常数空间不断遍历  
    2. 先构造后证明的贪心  
    构造一个贪心解法, 如基于循环移位/不同的x/二分限定的范围之后，能否找到一种不坏的策略, 后证明最优性  
    3. 结构特征  
    0 - 1 - 0 的分段结构不会改变  
    4. 逆向特征  
    正着减 - 反着加  
    5. 数值特征
    只需要满足最大频率的数小于长度的一半即可  
    

### 猜想构造

1. 逆向考虑  
    给定解 判断参数的范围 / 是否满足  
    (加密密码本匹配源码)  

2. 另一种角度理解  
    蚂蚁的相遇问题 - 改变身份   
    根据子集还原数组 - 每次删除施加影响的数值的集合  
    从Hash mask角度考虑  
    矩阵整体特性  

3. 解的范围与形式  
    ! 对于难以归纳的问题，应该观察结构, 尝试逆向思考  
    常见的贪心结论  
    只需满足频次不大与n/2即可, 只需满足在一个区间内即可  
    插入所有可能的解遍历判断合理性  

### 状态转移  

！递推的逻辑，而不是搜索的逻辑  

1. 一般思路  
    1. 定义出一般式，优先看(i,i-1,i-j)与(j,j-1,j-i)排列组合的转移可能性  

    2. 枚举规律 (杨辉三角)  

    3. 对于数据量少，考虑状态压缩，枚举子集，并判断转移的有效性, 对限制多的问题，如求最大差值, 可以通过遍历增加限制  

    4. 对存在路径间多次更新的问题, 考虑等价的贪心，如青蛙跳问题，优先满足更近的地方，滑动窗口更新忽略了二次跳,出现了多次更新的问题  

    5. 正向更新较为复杂, 转化为记忆化搜索剪枝, 或后向更新 f(i + j) = max(f(i), f(i + j))  

    6. 考虑从单调性的角度简化最佳转移点  

2. 具体模型  

    1. 图类DP的处理  
        a. 对不满足拓扑顺序, 增加一个以当前元素结尾的条件，或预先进行一次拓扑排序  
        b. 对环的处理 - 倍增数组，限定长度为n  
        c. 对涉及到多个主体的问题，需要设置步数/轮数，防止重复更新  

    2. 区间类DP的处理  
        a. 对于长度为k的DP, 无法直接通过加减来舍弃掉多出一个元素的影响，可以考虑堆/单调队列优化，或基于贪心的滑动DP(青蛙跳，优先转移所有能转移的)  
        b. 对于重复数，合并反而减少了信息量（总长度有限制），单个元素的转移更加灵活，删与被删，不需计数  
        c. 对于多状态的定义，尝试抽象更一般的特征，如atcoder 248, 从上下两端连通性的角度定义问题  
        d. 对于涉及多个相邻元素联系的问题，考虑枚举还没发生的状态  
        e. 若存在一定数学依赖，可以考虑线段树的简化  
        f. 对于距离类问题，直接定义当前节点为dp不符合拓扑结构，可以考虑优先队列搜索，或定义距离的DP  
        g. 对于数值关系复杂的转移，尝试离散的考虑每个元素，将需要判断具体需要多少的数值问题转化成能否转移的问题  


    3. 组合类DP的处理  
        a. 注意集合的划分可以从多角度定义  
        b. 通常使用限定最后元素来定义dp, 能够较好的避免重复, 其中可以定义多个最后元素的状态，便于转移  
        c. 更一般的, 也可以定义一个不含0的模型，和含0的模型思考转移(数学规律一致)  
        d. 可以参考容斥原理，对DP的结果做修正  
        e. 抽象出组合模型（球箱，求和公式...) 简化  

3. else  
   注意对遍历过而不能完成的状态 -1（未遍历） - INF（失败） 区分  
   可以使用map防止溢出  
   !注意空间简化一维之后，需要更新新一轮的默认值


### 搜索

1. 递归搜索 (dfs)  
   condition - receive - execution - return  
   搜索每个子状态 - 可以结合记忆化  
   汉诺塔拆分状态  
2. 队列搜索  
   dijkstra 优先队列 以单调递增量作为距离即可  
   0-1 bfs有隐含条件  
3. 基于DP的搜索  
   spfa floy...  
4. 基于贪心简化循环  
   bit角度, ++ - lowbit(i)  
   几何性质, 考虑两条相邻直线的k值即可  

### 二分

1. f(x)的二元性  
2. 边界的讨论 l = mid / r = mid - 1的选择  

## 数据结构

允许存在待处理的元素，添加一个标记位，最后再处理(懒更新)  
其中包括线段树的懒更新，保存index的单调队列，存在冗余项的优先队列  

1.  双向链表 + 哈希表  
    hashmap O(1) 寻址（！性能可能退化）  
    O(1)删除 链表  
    如: LRU / LFU  
    通配符哈希，便于解决双层哈希问题  
2.  Set(红黑树)  
    可以O(logn)删除，O(logn）寻址  
    multiset 多个元素  
    难以进行区间处理  
    注意求指针距离的复杂度为O(n)， 不同于vector  
3.  堆 | 优先队列  
    O(logn)插入  
    堆无法寻址删除 但可以维护一个贪心状态  
    两个堆(对顶堆)可以维护一个中位数的值  
4.  栈 | 双向队列  
    维护一个距离上的关联, 只能增加修改两侧元素  
    ! 对于弹出的元素，当前元素代表真正的解的位置，对于当前元素，栈内的元素代表解的空间  
    可用于递归调用的实现  
    用于运算符等涉及空间逻辑关系  
    在0－1BFS中双向队列可以完成最小路径的寻找  
5.  线段树  
    基于已有的区间范围，维护每个区间数值上的关系  
6.  双指针  
    快慢指针可以判断链表的环  
    滑动窗口维护单调性  
    T-F问题 区间有唯一性  
7.  单调队列  
    可以logn寻址，但只能增加/修改元素，或只需要弹出一侧的元素  
    ! 对于弹出的元素，当前元素代表真正的解的位置，对于当前元素，栈内的元素代表解的空间  
    ! 解的单调性证明：逆向考虑，若解中存在递减元素，则一定不符合条件，因此队列递增  
    若弹出条件是否等于，确定弹出元素的解是否为严格小于，而当前元素可以选择严格小于，也可以选择小于等于  
    在最大递增子串中可以用来更新维护贪心的状态  
8.  状态指针  
    数据的变化具有单调性，只需要记录当前位置即可  
9.  并查集  
    logn合并集合，但不能拆集合  
    通过排序/优先队列，根据单调性合并，二维接雨水  
10. 字典树  
    通常用于字符集的组合有限，而数量多的情况  
    合并有限个节点一致的关系，可以是一个多元数组(a, b), 若加入通配符机制，可以适用于前后缀同时的问题  

## 数理性质

1. 排列组合类  
   卢卡斯定理快速计算组合  
   生成next permulation  
   C(n, m) = C(不包含当前元素) + C(包含当前元素) = C(n - 1, m) + C(n - 1, m - 1)  
   1. 累加求和，从杨辉三角可以看出，若C(n, m)中m不变，求和可以合并  

   2. 通过dp思想枚举最后一个元素, 防止元素重复  

   3. 球箱模型: 十二重计数 容斥原理(并集转换为交集，并快速求交集), 斯特林数(不同的数之间的划分方式), 隔板(不同箱子，相同小球, 不定方程的解), 划分数(DP思路, 对不含0的的转移，根据限制，等价于所有数加一)  

2. 因子类  
    1. 同余问题  
    a 求乘法逆元，egcd gcd log(n)(欧拉 需要知道质因子个数)  
    b 运算类，注意加减乘都不改变同余的特性, 整除运算会改变, 其中组合数需要用到卢卡斯定理  
    c 线性同余方程等价, ax + bq = c  

    2. 质因子  
    a 对于提取公因子个数 nsqrt(n) 提取质因子nsqrt(n)  
    b 质因数分解中剩余项为质数  

3. 计算类
   快速乘/幂 乘法 - 指数  
   异或的性质 不具备分配律...  
   取整函数，通过乘积形式，拆括号  

4. 数理统计类
   信息量 熵 设计实验  
   随机数的生成  

5. 博弈类
   逐步贪心讨论必胜态 - 注意奇数偶数
   记忆化搜索判断是否有必胜态

6. 几何类
   求K值 凸包

## 应用场景

### 字符串处理

KMP, nextval优化, Z-prefix  
hash, 可采用通配符，辅助hash, 而不需要使用双层hash结构  
Trie, 多个元素的Trie优化, 将前后缀组合

1. 子串匹配类
    abcabc的子串匹配 - abc的前后缀匹配  

2. 回文括号  
    下一个最大回文串，拆分  

### 图/树

1. 距离类  
   聚点 - 源点 网络流 dijkstra spfa floy bfs dfs 剪枝  
   直径等 多次dfs    

2. 拓扑/分类  
   拓扑排序/染色  
   并查集  

3. DP类
   binary lifting LCA  

### 区间

1. 数据结构+  
   优先队列 | 单调栈 | 双指针 | 线段树  
2. 预处理  
   pre/suf计算  
3. 区间DP  

## 编程实现  

### 数据类型

1. 函数的返回值类型是int... 改为long long  
2. 初始化，d[0] = 0 - d[s]  
3. 位运算优先级低  

### 逻辑顺序

1. 提前break and continue 影响了后面的结果  
   cin / cout  cur[k] = cur[k - 1]  
   dp同理需要注意 dp[k] = dp[k - 1]  
2. 注意复用的值  
   链表的指向  
   ! a[2] -= d 范围a[1] + a[2]  

### else

1. 输入输出 ? break会影响cin  
2. 数据逻辑，存在不属于链表中的点。  
3. auto in lambda 是c++14的特性 decltype  
4. trick assert 小数据暴搜 大数据优化 分开两个算法  
5. 对空间、时间、数值范围的估计  

