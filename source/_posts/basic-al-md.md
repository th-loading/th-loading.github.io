---
title: 基本算法思路
date: 2022-01-30 16:01:59
tags: algorithm
---

# algorithm  

## 数据结构

1.  双向链表 + 哈希表  
    hashmap O(1) 寻址（！性能可能退化）  
    O(1)删除 链表  
    如: LRU / LFU  
2.  Set(红黑树)  
    可以O(logn)删除，O(logn）寻址  
    multiset 多个元素  
    难以进行区间处理  
    注意求指针距离的复杂度为O(n)， 不同于vector  
3.  堆  
    O(logn)插入  
    堆无法寻址删除 但可以维护一个全局最优状态  
    对顶堆可以维护一个中位数的值  
4.  单调栈 | 双向队列
    可以logn寻址，但只能增加/修改元素，不能删除  
    能够获得区间长度  
    借助单调栈input和output的顺序，可以确定区间距离上最近/最远的最值
    点  
    在0－1BFS中双向队列可以完成最小路径的寻找  
    在最大递增子串中可以用来维护贪心的状态    
5.  线段树  
    基于已有的区间范围，维护每个区间数值上的关系  
6.  双指针  
    快慢指针可以判断链表的环  
    滑动窗口维护单调性  
    T-F问题 区间有唯一性  
7.  并查集  
    logn合并集合，但不能拆集合  

## 基本思路

### 重定义

1. 逆向考虑  
   给定解 判断参数的范围 / 是否满足  
   ！加密密码本匹配源码  
2. 拆分问题  
   枚举弱问题 - 合并 ！对解的区间的理解  
   枚举符合条件的minw, 循环移位...  
   多次更新 再合并考虑 先满足左侧的需求，后更新右侧的问题。  
3. 逻辑等价
   蚂蚁的相遇问题 - 只是交换的身份   
   多个物件也可以看成一个整体的背包
4. 定义方式  
   根据子集还原数组 - 每次删除施加影响的数值的集合  
   找每个符合条件的子集 x - 找转变后不影响结果的部分  
   利用hash，前缀，mask重新编码

### 状态转移  

1. 易于转移  
   可以通过遍历增加限制，或多求几遍值  
   只要满足拓扑顺序，可以任意更新顺序  
   对环的处理 - 倍增数组，限定长度为n  

2. 能够还原  
   可以预留一些状态  
   可以从后往前更新  
   从范围、轮数等有限状态定义  
   ！理清集合之间的重复关系，能够直接进行加减

3. 优化  
   最佳转移点是否离散或有单调性  
   重新排列合并公式   
   前缀和可以累加

4. else

   注意对遍历过而不能完成的状态 -1（未遍历） - INF（失败） 区分  

### 搜索

1. 递归搜索 (dfs)
   condition - receive - execution - return  
   搜索每个子状态 - 可以结合记忆化  
   汉诺塔拆分状态  
2. 队列搜索  
   dijkstra 优先队列 以单调递增量作为距离即可  
   0-1 bfs有隐含条件  
3. 基于动态规划的搜索  
   spfa floy...  

### 二分

1. f(x)的二元性  
2. 边界的讨论   

### 贪心

1. 不需要构造，只需要证明存在 range...  
2. 注意局部最优里可能隐含了全局最优的集合  
3. 忽略一些一定不是最优解的部分 从bit的角度...  
4. 先贪心后减去冗余  


### trick

基于简单的例子归纳  
限定一定范围即可爆搜  

## 数理性质

1. 排列组合类

   快速计算组合 next permulation 

2. 因子类

   egcd 公因子个数 提取质因子

3. 计算类

   快速乘/幂 乘法 - 指数
   异或的性质

4. 数理统计类

   信息量 熵 设计实验

   随机数的生成

5. 博弈类

   逐步贪心讨论必胜态 - 注意奇数偶数

   记忆化搜索判断是否有必胜态

6. 几何类

   求K值 凸包

## 应用场景

### 字符串处理

1. 子串匹配类

   KMP hash trie

2. 回文

### 图/树

1. 距离类
   聚点 - 源点 网络流 dijkstra spfa floy bfs dfs 剪枝

   直径等 多次dfs    

2. 拓扑/分类  
   拓扑排序/染色  
   并查集  

3. DP类

   binary lifting LCA

### 区间

1. 数据结构+  
   优先队列 | 单调栈 | 双指针 | 线段树  
2. 预处理  
   pre/suf计算  
3. 区间DP

## 编程实现  

### 数据类型

1. 函数的返回值类型是int... 改为long long  
2. 初始化，d[0] = 0 - d[s]  
3. 位运算优先级低  

### 逻辑顺序

1. 提前break and continue 影响了后面的结果  
   cin/cout  cur[k] = cur[k - 1]  
   dp同理需要注意 dp[k] = dp[k - 1]  
2. 注意复用的值  
   链表的指向  

### else

1. 输入输出 ? break会影响cin  
2. 数据逻辑，存在不属于链表中的点。  
3. auto in lambda 是c++14的特性 decltype  
4. trick assert 小数据暴搜 大数据优化 分开两个算法  
5. 对空间、时间、数值范围的估计 

