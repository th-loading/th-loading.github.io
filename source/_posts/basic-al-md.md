---
title: 基本算法思路
date: 2022-01-30 16:01:59
tags: algorithm
---

# algorithm  

## 数据结构

1.  双向链表 + 哈希表  
    hashmap O(1) 寻址（！性能可能退化）  
    O(1)删除 链表  
    如: LRU / LFU  
2.  Set(红黑树)  
    可以O(logn)删除，O(logn）寻址  
    multiset 多个元素  
    难以进行区间处理  
    注意求指针距离的复杂度为O(n)， 不同于vector  
3.  堆  
    O(logn)插入  
    堆无法寻址删除 但可以维护一个全局最优状态  
    对顶堆可以维护一个中位数的值  
4.  单调栈 | 双向队列  
    可以logn寻址，但只能增加/修改元素，不能删除  
    能够获得区间长度  
    借助单调栈input和output的顺序，可以确定区间距离上最近/最远的最值
    点  
    在0－1BFS中双向队列可以完成最小路径的寻找  
    在最大递增子串中可以用来维护贪心的状态  
    允许存在冗余的元素，最后再处理  

5.  线段树  
    基于已有的区间范围，维护每个区间数值上的关系  
6.  双指针  
    快慢指针可以判断链表的环  
    滑动窗口维护单调性  
    T-F问题 区间有唯一性  
7.  并查集  
    logn合并集合，但不能拆集合  

## 基本思路

### 猜想构造
从最小的单元开始，!先考虑直接的定义域, 值域, 而非间接的关联  

1. 改变目标
    1. 逆向考虑  
    给定解 判断参数的范围 / 是否满足  
    (加密密码本匹配源码)  

    2. 另一种角度理解  
    蚂蚁的相遇问题 - 改变身份   
    根据子集还原数组 - 每次删除施加影响的数值的集合  
    从Hash mask角度考虑  

    3. 对解的形式的猜想  
    子序列内不存在频次超过n/2即可删...  
    只需要在一个范围内即可  

    4. 隐含性质  
    先考虑第一个或最后一个值或整体特性  
    确认一种顺序 （拓扑 数值...) 考虑  

2. 改变方式  
合并简化，+= lowbit(i)  
对于复杂计算，考虑先计算再回退 | 懒更新的思路 后面再解决  
对于多限制的问题，尝试更一般的循环或枚举一部分限制  

3. trick  
通常基于模块，子问题，案例多为干扰项  
限定一定范围即可爆搜 !无需分类  

### 状态转移  
基于一组最难满足的解  
注意数值范围与空间的关联  

1. 易于转移  
   可以通过遍历增加限制，或多求几遍值  
   对存在单调条件，可以尝试多次，逆向更新  
   对不满足拓扑顺序, 增加一个以当前元素结尾的条件，或预先进行一次拓扑排序  
   对环的处理 - 倍增数组，限定长度为n  
   对于重复数，合并反而减少了信息量（总长度有限制），单个元素的转移更加灵活，删与被删，不需计数  

2. 能够还原  
   可以预留一些状态  
   可以从后往前更新  
   从范围、轮数等有限状态定义  
   ！理清集合之间的重复关系，能够直接进行加减

3. 优化  
   最佳转移点是否离散或有单调性  
   重新排列合并公式   
   前缀和可以累加

4. else  
   注意对遍历过而不能完成的状态 -1（未遍历） - INF（失败） 区分  
   可以使用map防止溢出  

### 搜索

1. 递归搜索 (dfs)  
   condition - receive - execution - return  
   搜索每个子状态 - 可以结合记忆化  
   汉诺塔拆分状态  
2. 队列搜索  
   dijkstra 优先队列 以单调递增量作为距离即可  
   0-1 bfs有隐含条件  
3. 基于DP的搜索  
   spfa floy...  
4. 基于贪心简化循环  
    bit角度, ++ - lowbit(i)  
    几何性质, 考虑两条相邻直线的k值即可  

### 二分

1. f(x)的二元性  
2. 边界的讨论   

## 数理性质

1. 排列组合类

   快速计算组合 next permulation 

2. 因子类

   egcd 公因子个数 提取质因子

3. 计算类

   快速乘/幂 乘法 - 指数  
   异或的性质 不具备分配律...  

4. 数理统计类

   信息量 熵 设计实验

   随机数的生成

5. 博弈类

   逐步贪心讨论必胜态 - 注意奇数偶数

   记忆化搜索判断是否有必胜态

6. 几何类

   求K值 凸包

## 应用场景

### 字符串处理

1. 子串匹配类

   KMP hash trie

2. 回文

### 图/树

1. 距离类  
   聚点 - 源点 网络流 dijkstra spfa floy bfs dfs 剪枝  
   直径等 多次dfs    

2. 拓扑/分类  
   拓扑排序/染色  
   并查集  

3. DP类

   binary lifting LCA

### 区间

1. 数据结构+  
   优先队列 | 单调栈 | 双指针 | 线段树  
2. 预处理  
   pre/suf计算  
3. 区间DP

## 编程实现  

### 数据类型

1. 函数的返回值类型是int... 改为long long  
2. 初始化，d[0] = 0 - d[s]  
3. 位运算优先级低  

### 逻辑顺序

1. 提前break and continue 影响了后面的结果  
   cin/cout  cur[k] = cur[k - 1]  
   dp同理需要注意 dp[k] = dp[k - 1]  
2. 注意复用的值  
   链表的指向  

### else

1. 输入输出 ? break会影响cin  
2. 数据逻辑，存在不属于链表中的点。  
3. auto in lambda 是c++14的特性 decltype  
4. trick assert 小数据暴搜 大数据优化 分开两个算法  
5. 对空间、时间、数值范围的估计  

